wtd:

NEXT:

sicher:

jedem philo einen eigenen mutex geben der seine:

	pthread_mutex_lock(ph->input->live);
	ph->lte = f_get_time();
	ph->ate_x_times += 1;
	pthread_mutex_unlock(ph->input->live);

sperrt und updated

diesen extra mutex dann als ghost sperren zum ausrechnen.
entsperren und dann handeln siehe discord



evtl:
	-> edgecase 1 philo before thread_create() , dann kann ich one philo rauslöschen aus philo routine
		und starte die thread creation gar nicht

zuletzt erledigt:

	-> ghost routine
	-> threads creation
	-> join threads

	-> void	f_philo_think(t_philo *ph);			löschen und einfach ausführen in philo_eat();
	-> dann habe ich platz für take_fork(pthread_mutex_t	*fork); und leave_fork(pthread_mutex_t	*fork);


-> philo routine
-> philo actions 
-> ghost routine angelegt
-> threads create angelegt




