wtd:

NEXT:

 f_threads_create.c 

make life an int not a bool ether do 0 1 2 or 1 0 -1
 after line 44 make a fucntion like f_kill() to set life to 1
 that for i have to initialise it to 2
 and if it is 0 stop -> trigger death seqence
 if its 2 wait for al philos

 strings remove dots ..

 TESTS:

	(ulimit -u 1380 && valgrind --tool=helgrind ./philo 199 610 200 200)
  	(ulimit -u 1379 && valgrind --tool=helgrind ./philo 199 610 200 200)
  	(ulimit -u 1360 && valgrind --tool=helgrind ./philo 199 610 200 200)
  	(ulimit -u 1380 && valgrind ./philo 199 610 200 200)
  	(ulimit -u 1180 && valgrind ./philo 199 610 200 200)
  	(ulimit -u 1280 && valgrind ./philo 199 610 200 200)




zuletzt erledigt:



README

TESTS:
	
	- malloc fails forcen
	- mutex init error forcen (viele in f_init_table)
	- pthread create error forcen (f_init_threads)

	- stresstests viele philos

cc -g -fsanitize=thread *.c
setarch $(uname -m) -R ./a.out 4 1100 500 500 3
setarch $(uname -m) -R ./a.out 4 500 500 500 3

cc -g *.c 
valgrind --leak-check=full ./a.out 4 410 200 200 2
valgrind --tool=helgrind ./a.out 4 410 200 200 2

cc *.c
./a.out 200 410 200 200
./a.out 200 800 200 200


TESTS:

norminette
-wall -wextra -werror
MAKEFILE

philo.c

jedem philo einen eigenen mutex geben der seine:

	pthread_mutex_lock(ph->input->live);
	ph->lte = f_get_time();
	ph->ate_x_times += 1;
	pthread_mutex_unlock(ph->input->live);

sperrt und updated

diesen extra mutex dann als ghost sperren zum ausrechnen.
entsperren und dann handeln siehe discord


	-> ghost routine
	-> threads creation
	-> join threads

	-> void	f_philo_think(t_philo *ph);			löschen und einfach ausführen in philo_eat();
	-> dann habe ich platz für take_fork(pthread_mutex_t	*fork); und leave_fork(pthread_mutex_t	*fork);


-> philo routine
-> philo actions 
-> ghost routine angelegt
-> threads create angelegt




